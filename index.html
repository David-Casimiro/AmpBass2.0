<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0"/>
<title>Q-16 Live + Simple Synth (Safari iOS)</title>

<script src="https://cdn.tailwindcss.com"></script>

<style>
  body { background:#020617; color:#e6f7ff; font-family:system-ui,-apple-system,sans-serif; }
  .card { background:linear-gradient(180deg,#041022,#021019); border:1px solid #11323f; border-radius:12px; padding:12px; }
  button{ transition:all .12s ease; }
  canvas{ background:#000; border-radius:8px; display:block; width:100%; height:110px; }
  .small{ font-size:.85rem; color:#9fd7ff; }
  .muted{ color:#9ca3af; font-size:.8rem; }
  .key{ user-select:none; touch-action:none; }
  .white{ background:white; color:black; border:1px solid #ccc; height:64px; border-radius:4px; display:inline-block; width:36px; margin-right:3px; text-align:center; line-height:64px;}
  .black{ background:black; color:white; position:relative; left:-14px; width:24px; height:40px; display:inline-block; margin-right:3px; z-index:2; border-radius:3px; text-align:center; line-height:40px; }
  .kbd-row{ display:flex; gap:6px; align-items:flex-end; }
  .controls-grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:8px; }
  input[type=range]{ width:100%; touch-action:none; }
</style>
</head>
<body class="p-4 max-w-lg mx-auto">

<header class="text-center mb-3">
  <h1 class="text-2xl font-bold">üéõÔ∏è Q-16 Live + Simple Synth</h1>
  <p class="small">Optimized Safari iOS ‚Ä¢ Q-16 ‚Ä¢ Worklet + Synth</p>
</header>

<section class="card mb-3">
  <div class="flex gap-2 mb-2">
    <button id="connectBtn" class="flex-1 py-2 rounded bg-emerald-600 font-semibold">Conectar & Ativar</button>
    <button id="enumBtn" class="py-2 px-3 rounded bg-sky-600">Atualizar</button>
  </div>

  <label class="small muted">Entrada (conecte Q-16 antes)</label>
  <select id="deviceSel" class="w-full p-2 rounded bg-black/40 mb-2"></select>

  <div class="grid grid-cols-2 gap-2 mb-2">
    <button id="powerBtn" class="py-2 rounded bg-green-600">Power ON</button>
    <button id="muteBtn" class="py-2 rounded bg-yellow-500">MIC ON</button>
  </div>

  <div class="mb-2">
    <label class="small">Input Gain</label>
    <input id="inputGain" type="range" min="0" max="6" step="0.01" value="1">
  </div>
  <div class="mb-2">
    <label class="small">Master Volume</label>
    <input id="masterGain" type="range" min="0" max="1.5" step="0.01" value="0.9">
  </div>

  <div class="mb-2">
    <label class="small">Mix (Mic ‚Üî Synth)</label>
    <input id="mix" type="range" min="0" max="1" step="0.01" value="0.6">
    <div class="muted text-xs">0 = s√≥ synth | 1 = s√≥ mic</div>
  </div>

  <p class="muted text-xs mt-2">Use este app como camada FX. Mantenha sinal direto da mesa em redund√¢ncia em shows.</p>
</section>

<section class="card mb-3">
  <label class="small">Visualizador</label>
  <canvas id="scope"></canvas>
</section>

<section class="card mb-3">
  <div class="flex justify-between items-center mb-2">
    <div><strong>Synth ‚Äî teclado</strong> <span class="muted"> (clic/touch para tocar)</span></div>
    <div class="muted text-xs" id="midiStatus">MIDI: tentando...</div>
  </div>

  <div class="controls-grid mb-2">
    <div>
      <label class="small">Waveform</label>
      <select id="waveform" class="w-full p-2 rounded bg-black/30">
        <option value="sine">Sine</option>
        <option value="sawtooth">Saw</option>
        <option value="square">Square</option>
        <option value="triangle">Triangle</option>
      </select>
    </div>

    <div>
      <label class="small">Polyphony</label>
      <input id="poly" type="number" min="1" max="8" value="4" class="w-full p-2 rounded bg-black/30">
    </div>

    <div>
      <label class="small">Attack (ms)</label>
      <input id="att" type="range" min="0" max="200" step="1" value="8">
    </div>

    <div>
      <label class="small">Release (ms)</label>
      <input id="rel" type="range" min="10" max="1000" step="5" value="150">
    </div>

    <div>
      <label class="small">Sustain</label>
      <input id="sus" type="range" min="0" max="1" step="0.01" value="0.8">
    </div>

    <div>
      <label class="small">Decay (ms)</label>
      <input id="dec" type="range" min="0" max="1000" step="5" value="80">
    </div>
  </div>

  <!-- on-screen keyboard: one octave (C4 to B4) -->
  <div id="keyboard" class="kbd-row"></div>
</section>

<section class="muted text-xs mb-4">
  Toque no teclado acima ou conecte um controlador MIDI (se suportado pelo navegador). iOS Safari: Web MIDI geralmente n√£o dispon√≠vel ‚Äî use teclado na tela.
</section>

<footer class="text-center text-xs text-gray-400">Q-16 Live + Synth ‚Äî Experimental ‚Äî Teste antes do show</footer>

<script>
/* ============================
  Combined WebAudio App:
  - AudioWorklet pass-through for input (mic/interface)
  - Synth generated in main thread (Oscillators + Gain + ADSR)
  - Mixer (micGain, synthGain) into masterGain -> destination
  - Device select, MIDI attempt, minimal visualizer
============================ */

const connectBtn = document.getElementById('connectBtn');
const enumBtn = document.getElementById('enumBtn');
const deviceSel = document.getElementById('deviceSel');
const powerBtn = document.getElementById('powerBtn');
const muteBtn = document.getElementById('muteBtn');

const inputGainEl = document.getElementById('inputGain');
const masterGainEl = document.getElementById('masterGain');
const mixEl = document.getElementById('mix');

const waveformSel = document.getElementById('waveform');
const polyEl = document.getElementById('poly');
const attEl = document.getElementById('att');
const decEl = document.getElementById('dec');
const susEl = document.getElementById('sus');
const relEl = document.getElementById('rel');

const scope = document.getElementById('scope');
const ctx = scope.getContext('2d');
const keyboardDiv = document.getElementById('keyboard');
const midiStatus = document.getElementById('midiStatus');

let audioCtx = null;
let micStream = null;
let micSource = null;
let inputWorklet = null; // worklet node for pass-through
let micGainNode = null;
let synthGainNode = null;
let masterGainNode = null;
let analyser = null;
let running = false;
let micOn = true;

// Synth voices map: note -> {osc, gain, timeout}
const voices = new Map();

// note frequencies for C4..B4
const NOTES = [
  {name:'C4', freq:261.6256},
  {name:'C#4', freq:277.1826},
  {name:'D4', freq:293.6648},
  {name:'D#4', freq:311.1270},
  {name:'E4', freq:329.6276},
  {name:'F4', freq:349.2282},
  {name:'F#4', freq:369.9944},
  {name:'G4', freq:392.0},
  {name:'G#4', freq:415.3047},
  {name:'A4', freq:440.0},
  {name:'A#4', freq:466.1638},
  {name:'B4', freq:493.8833}
];

// Worklet code as blob (pass-through with inputGain parameter)
const workletSrc = `
class PT extends AudioWorkletProcessor {
  static get parameterDescriptors(){ return [{name:'inputGain', defaultValue:1, minValue:0, maxValue:10}]; }
  process(inputs, outputs, parameters){
    const inCh = inputs[0];
    const outCh = outputs[0];
    if(!inCh || inCh.length===0) return true;
    const input = inCh[0];
    const output = outCh[0];
    const g = parameters.inputGain;
    for(let i=0;i<input.length;i++){
      const ig = g.length>1 ? g[i] : g[0];
      output[i] = input[i]*ig;
    }
    return true;
  }
}
registerProcessor('pt-processor', PT);
`;
const workletBlob = new Blob([workletSrc], {type:'application/javascript'});
const workletURL = URL.createObjectURL(workletBlob);

/* --------- enumerate devices ---------- */
async function enumerateDevices(){
  deviceSel.innerHTML = '<option>Procurando...</option>';
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const inputs = devices.filter(d=>d.kind==='audioinput');
    deviceSel.innerHTML = '';
    if(inputs.length===0){
      const opt = document.createElement('option'); opt.value=''; opt.textContent='Nenhuma entrada detectada';
      deviceSel.appendChild(opt); return;
    }
    inputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || ('device: '+d.deviceId.slice(0,6));
      deviceSel.appendChild(opt);
    });
  }catch(e){
    deviceSel.innerHTML = '<option value="">Erro</option>';
    console.warn('enumerateDevices', e);
  }
}

/* ----- connect / setup audio graph ----- */
connectBtn.onclick = async () => {
  try{
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive', sampleRate:48000 });
      await audioCtx.audioWorklet.addModule(workletURL);
    }
    // choose device if any
    const deviceId = deviceSel.value || undefined;
    const constraints = {
      audio:{
        deviceId: deviceId ? { exact: deviceId } : undefined,
        sampleRate:48000,
        channelCount:1,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false,
        latency:0
      }
    };
    micStream = await navigator.mediaDevices.getUserMedia(constraints);
    micSource = audioCtx.createMediaStreamSource(micStream);

    inputWorklet = new AudioWorkletNode(audioCtx, 'pt-processor', { parameterData: { inputGain: Number(inputGainEl.value) }});
    micGainNode = audioCtx.createGain(); // for mix control, though worklet handles input gain
    micGainNode.gain.value = 1;

    synthGainNode = audioCtx.createGain();
    synthGainNode.gain.value = 1;

    masterGainNode = audioCtx.createGain();
    masterGainNode.gain.value = Number(masterGainEl.value);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;

    // mic chain: micSource -> worklet -> micGainNode -> masterMix
    micSource.connect(inputWorklet).connect(micGainNode);

    // create a merger for mic & synth then to analyser -> destination
    const merger = audioCtx.createGain(); // acts as mixer summing node
    micGainNode.connect(merger);
    synthGainNode.connect(merger);

    merger.connect(analyser).connect(masterGainNode).connect(audioCtx.destination);

    running = true;
    connectBtn.textContent = 'Conectado';
    connectBtn.disabled = true;
    powerBtn.textContent = 'Power ON ‚úì';

    // update device list labels now that permission granted
    await wait(200);
    enumerateDevices();
    draw(); // start visual
    tryInitMIDI();
  }catch(err){
    console.error('connect error', err);
    alert('Erro ao conectar: '+(err.message||err));
  }
};

/* helper wait */
const wait = ms => new Promise(r=>setTimeout(r,ms));

enumBtn.onclick = enumerateDevices;

powerBtn.onclick = async () => {
  if(!audioCtx) return alert('Conecte primeiro');
  if(audioCtx.state === 'suspended'){ await audioCtx.resume(); powerBtn.textContent='Power ON ‚úì'; }
  else { await audioCtx.suspend(); powerBtn.textContent='Power SUSP'; }
};

muteBtn.onclick = () => {
  micOn = !micOn;
  // set mic gain (mix controls will adjust final mix)
  micGainNode && (micGainNode.gain.value = micOn ? 1 : 0);
  muteBtn.textContent = micOn ? 'MIC ON' : 'MIC OFF';
  muteBtn.classList.toggle('bg-gray-600', !micOn);
};

inputGainEl.oninput = () => {
  if(inputWorklet) inputWorklet.parameters.get('inputGain').setValueAtTime(Number(inputGainEl.value), audioCtx.currentTime);
};

masterGainEl.oninput = () => {
  if(masterGainNode) masterGainNode.gain.value = Number(masterGainEl.value);
};

mixEl.oninput = () => {
  // mix: 0 = synth only, 1 = mic only
  const m = Number(mixEl.value);
  if(micGainNode && synthGainNode){
    micGainNode.gain.value = m;
    synthGainNode.gain.value = 1 - m;
  }
};

/* -------- Synth implementation (simple polyphonic) -------- */
function createVoice(freq){
  if(!audioCtx) return null;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = waveformSel.value || 'sine';
  osc.frequency.value = freq;
  gain.gain.value = 0;
  // connect to synthGainNode
  osc.connect(gain).connect(synthGainNode);
  osc.start();
  return {osc,gain};
}

function noteOn(freq, key){
  // enforce polyphony
  const poly = Math.max(1, Math.min(8, parseInt(polyEl.value)||4));
  if(voices.size >= poly){
    // simple voice stealing: remove first
    const firstKey = voices.keys().next().value;
    noteOff(firstKey);
  }
  const v = createVoice(freq);
  if(!v) return;
  const now = audioCtx.currentTime;
  const att = Math.max(0.001, Number(attEl.value)/1000);
  const dec = Number(decEl.value)/1000;
  const sus = Number(susEl.value);
  // attack to 1.0, then decay to sustain
  v.gain.gain.cancelScheduledValues(now);
  v.gain.gain.setValueAtTime(0.0001, now);
  v.gain.gain.exponentialRampToValueAtTime(1.0, now + att);
  v.gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, sus), now + att + dec);
  voices.set(key, { node: v, started: now });
}

function noteOff(key){
  const rec = voices.get(key);
  if(!rec) return;
  const { node } = rec;
  const now = audioCtx.currentTime;
  const rel = Math.max(0.01, Number(relEl.value)/1000);
  node.gain.gain.cancelScheduledValues(now);
  node.gain.gain.setValueAtTime(node.gain.gain.value, now);
  node.gain.gain.exponentialRampToValueAtTime(0.0001, now + rel);
  // stop oscillator after release
  setTimeout(()=> {
    try{ node.osc.stop(); }catch(e){}
    try{ node.osc.disconnect(); node.gain.disconnect(); }catch(e){}
  }, (rel+0.05)*1000);
  voices.delete(key);
}

/* -------- Build on-screen keyboard -------- */
function buildKeyboard(){
  keyboardDiv.innerHTML = '';
  NOTES.forEach((n, idx) => {
    // render white keys and black keys overlayed roughly
    const isSharp = n.name.includes('#');
    const btn = document.createElement('div');
    btn.className = 'key ' + (isSharp ? 'black' : 'white');
    btn.textContent = n.name.replace('4','');
    btn.dataset.idx = idx;
    // pointer events
    btn.addEventListener('pointerdown', (e)=> {
      e.preventDefault();
      const k = 'k'+idx;
      if(!voices.has(k)) noteOn(n.freq, k);
    });
    btn.addEventListener('pointerup', (e)=> {
      e.preventDefault();
      const k = 'k'+idx;
      noteOff(k);
    });
    btn.addEventListener('pointerleave', (e)=> {
      e.preventDefault();
      const k = 'k'+idx;
      if(voices.has(k)) noteOff(k);
    });
    keyboardDiv.appendChild(btn);
  });
}

/* -------- Visualizer ---------- */
function draw(){
  if(!analyser) return;
  requestAnimationFrame(draw);
  const w = scope.clientWidth, h = scope.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  scope.width = Math.round(w * dpr);
  scope.height = Math.round(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const buffer = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buffer);

  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,w,h);
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#7dd3fc';
  ctx.beginPath();
  const step = Math.max(1, Math.floor(buffer.length/ (w/2) ));
  let x=0;
  const slice = w / (buffer.length/step);
  for(let i=0;i<buffer.length;i+=step){
    const v = buffer[i]/128.0;
    const y = v*h/2;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    x += slice;
  }
  ctx.stroke();
}

/* -------- Web MIDI (try) -------- */
async function tryInitMIDI(){
  if (!('requestMIDIAccess' in navigator)) {
    midiStatus.textContent = 'MIDI: n√£o suportado';
    return;
  }
  try{
    const midi = await navigator.requestMIDIAccess();
    midiStatus.textContent = 'MIDI: conectado';
    for (const input of midi.inputs.values()) {
      input.onmidimessage = (msg) => {
        const [status, data1, data2] = msg.data;
        const cmd = status >> 4;
        const channel = status & 0xf;
        if (cmd === 9) { // note on
          const note = data1;
          const vel = data2/127;
          const idx = note - 60; // map to C4=60
          if(idx>=0 && idx < NOTES.length){
            noteOn(NOTES[idx].freq, 'm'+note);
          }
        } else if (cmd === 8 || (cmd===9 && data2===0)) { // note off
          const note = data1;
          noteOff('m'+note);
        }
      };
    }
  }catch(e){
    midiStatus.textContent = 'MIDI: erro';
    console.warn('MIDI init', e);
  }
}

/* -------- init UI and keyboard -------- */
buildKeyboard();
enumerateDevices();
midiStatus.textContent = 'MIDI: init... (se dispon√≠vel)';

</script>
</body>
</html>
